// Generated by CoffeeScript 1.4.0
(function() {
  var content_css, css, default_confing, dir, elem_css, heightOf, log, page_css, paginate, sel, selAll, tpl, widthOf, wrapper_css;

  default_confing = {
    rows: 1,
    cols: 1,
    transSpeed: 500,
    index: 0,
    data: [],
    controls: true,
    focusedClass: 'focused',
    orientation: 'horizontal',
    onChange: function(elem) {},
    onExit: function(direction) {},
    selectors: {
      container: 'ul',
      wrapper: '.wrapper',
      content: '.content',
      focused: '.focused',
      elem: 'li',
      page: '.page',
      tpl: 'script[type="text/tpl"]'
    }
  };

  content_css = {
    position: 'relative',
    height: '100%'
  };

  wrapper_css = {
    overflow: 'hidden',
    margin: 0,
    padding: 0
  };

  page_css = {
    margin: 0,
    padding: 0,
    float: 'left'
  };

  elem_css = {
    float: 'left',
    'list-style': 'none'
  };

  paginate = function(arr, size) {
    var copy_arr, _results;
    size = size || arr.length;
    copy_arr = arr.slice(0);
    _results = [];
    while (copy_arr.length) {
      _results.push(copy_arr.splice(0, size));
    }
    return _results;
  };

  log = function(o) {
    return typeof console !== "undefined" && console !== null ? console.log(o) : void 0;
  };

  dir = function(o) {
    return typeof console !== "undefined" && console !== null ? console.dir(o) : void 0;
  };

  tpl = function(str) {
    str = str.replace('data-src', 'src');
    return function(data) {
      var res, val, _i, _len;
      res = '';
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        val = data[_i];
        res += str.replace(/\{(\w*)\}/g, function(s, p) {
          return val[p] || s;
        });
      }
      return res;
    };
  };

  sel = function(elem, sel) {
    return elem.querySelector(sel);
  };

  selAll = function(elem, sel) {
    var all, elements, val, _i, _len;
    elements = [];
    all = elem.querySelectorAll(sel);
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      val = all[_i];
      if (val instanceof Element) {
        elements.push(val);
      }
    }
    return elements;
  };

  heightOf = function(elem) {
    var bottom, top;
    top = getComputedStyle(elem, null).getPropertyValue('margin-top');
    bottom = getComputedStyle(elem, null).getPropertyValue('margin-bottom');
    return elem.offsetHeight + parseFloat(top) + parseFloat(bottom);
  };

  widthOf = function(elem) {
    var left, right;
    right = getComputedStyle(elem, null).getPropertyValue('margin-right');
    left = getComputedStyle(elem, null).getPropertyValue('margin-left');
    return elem.offsetWidth + parseFloat(left) + parseFloat(right);
  };

  css = function(elem, styles) {
    var key, style, val;
    style = [];
    if (elem instanceof Element) {
      for (key in styles) {
        val = styles[key];
        style.push("" + key + ": " + val);
      }
      elem.setAttribute('style', style.join(';'));
    }
    return elem;
  };

  this.Gridy = (function() {

    function Gridy(component_sel, options) {
      var c, controls, key, tpl_str, trans, transition, val, _i, _j, _len, _len1, _ref,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.options = {};
      for (key in default_confing) {
        val = default_confing[key];
        this.options[key] = val;
      }
      for (key in options) {
        val = options[key];
        this.options[key] = val;
      }
      this.el = sel(document, component_sel);
      if (!this.el) {
        throw new Error("DOM element with selector " + component_sel + " is not found");
      }
      this.wrapper = sel(this.el, this.options.selectors.wrapper);
      this.content = sel(this.el, this.options.selectors.content);
      tpl_str = sel(this.el, this.options.selectors.tpl);
      if (!this.options.tpl) {
        this.options.tpl = tpl(tpl_str.innerHTML);
      }
      transition = '';
      _ref = ['WebkitT', 'MozT', 'OT', 'MsT', 't'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        trans = _ref[_i];
        if (typeof document.body.style[trans + 'ransition'] === 'string') {
          transition = trans + 'ransition';
        }
      }
      if (!this.options.animate) {
        this.options.animate = function(direction, val, speed) {
          _this.content.style[transition] = "" + speed + "ms ease-in-out " + direction;
          return _this.content.style[direction] = "" + val + "px";
        };
      }
      if (this.options.data) {
        this.insert(this.options.data);
      }
      if (this.options.controls) {
        controls = [];
        if (this.options.cols > 1 || options.rows === 1) {
          controls.push('left');
          controls.push('right');
        }
        if (this.options.rows > 1) {
          controls.push('up');
          controls.push('down');
        }
        for (_j = 0, _len1 = controls.length; _j < _len1; _j++) {
          val = controls[_j];
          c = document.createElement('span');
          c.className = "" + val + " control";
          c.innerHTML = val;
          c.direction = val;
          c.addEventListener('click', function(e) {
            return _this.move(e.currentTarget.direction);
          });
          this.el.appendChild(c);
        }
      }
      return this;
    }

    Gridy.prototype.insert = function(data) {
      var c, col_width, cols, el_val, first_elem, first_page, key, page_size, paged, r, row_height, rows, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      if (data.length) {
        page_size = this.options.cols * this.options.rows;
        paged = '';
        _ref = paginate(data, page_size);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          val = _ref[_i];
          paged += '<ul class="page">' + (this.options.tpl(val)) + '</ul>';
        }
        if (paged) {
          this.content.innerHTML = paged;
        }
        this.elements = selAll(this.content, this.options.selectors.elem);
        this.pages = selAll(this.content, this.options.selectors.page);
        first_page = this.pages[0];
        first_elem = this.elements[0];
        css(this.content, content_css);
        css(this.wrapper, wrapper_css);
        if (this.elements) {
          _ref1 = this.elements;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            val = _ref1[_j];
            css(val, elem_css);
          }
        }
        row_height = heightOf(first_elem);
        col_width = widthOf(first_elem);
        if (this.pages) {
          _ref2 = this.pages;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            val = _ref2[_k];
            css(val, page_css);
            val.style.height = "" + (row_height * this.options.rows) + "px";
            val.style.width = "" + (col_width * this.options.cols) + "px";
          }
        }
        this.wrapper.style.width = "" + (widthOf(first_page)) + "px";
        this.wrapper.style.height = "" + (heightOf(first_page)) + "px";
        if (this.options.orientation === 'horizontal') {
          this.content.style.width = "" + (this.pages.length * widthOf(first_page)) + "px";
        } else {
          this.content.style.height = "" + (this.pages.length * heightOf(first_page)) + "px";
        }
        rows = {};
        cols = {};
        r = 0;
        c = 0;
        _ref3 = this.elements;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          val = _ref3[_l];
          if (!rows[val.offsetTop]) {
            rows[val.offsetTop] = [];
          }
          if (!cols[val.offsetLeft]) {
            cols[val.offsetLeft] = [];
          }
          cols[val.offsetLeft].push(val);
          rows[val.offsetTop].push(val);
        }
        for (key in rows) {
          val = rows[key];
          for (key in val) {
            el_val = val[key];
            el_val.setAttribute("data-r", r);
          }
          r += 1;
        }
        for (key in cols) {
          val = cols[key];
          for (key in val) {
            el_val = val[key];
            el_val.setAttribute("data-c", c);
          }
          c += 1;
        }
        this.focus(this.elements[this.options.index], 0);
      }
      return this;
    };

    Gridy.prototype.move = function(direction) {
      var c, focused, next, r;
      focused = sel(this.content, this.options.selectors.focused);
      if (focused) {
        r = parseInt(focused.getAttribute("data-r"));
        c = parseInt(focused.getAttribute("data-c"));
        switch (direction) {
          case "left":
            c -= 1;
            break;
          case "right":
            c += 1;
            break;
          case "up":
            r -= 1;
            break;
          case "down":
            r += 1;
            break;
        }
        next = sel(this.content, "[data-r='" + r + "'][data-c='" + c + "']");
        if (next) {
          next.classList.add(this.options.focusedClass);
          focused.classList.remove(this.options.focusedClass);
          this.focus(next, this.options.transSpeed);
        } else {
          this.options.onExit(direction);
        }
      }
      return this;
    };

    Gridy.prototype.focus = function(focused, speed) {
      var page;
      if (speed == null) {
        speed = 0;
      }
      if (focused) {
        focused.classList.add(this.options.focusedClass);
        page = focused.parentElement;
        if (this.options.orientation === "horizontal") {
          this.options.animate('left', -page.offsetLeft, speed);
        } else {
          this.options.animate('top', -page.offsetTop, speed);
        }
        this.options.onChange(focused);
      }
      return this;
    };

    return Gridy;

  })();

}).call(this);
